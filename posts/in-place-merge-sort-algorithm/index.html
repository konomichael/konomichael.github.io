<!doctype html><html lang=en><head><title>In-Place Merge Sort Algorithm :: Michael's space</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Merge sort is a popular sorting algorithm that has an average-case time complexity of O(n log n). The algorithm works by dividing the input array into two halves, sorting them recursively, and then merging them back together. However, the standard merge sort algorithm requires extra memory to hold the two sub-arrays during the merge step, which can be a bottleneck for large arrays. In contrast, in-place merge sort is a variant of the merge sort algorithm that sorts the array in place, using no extra memory.
In this blog post, we&amp;rsquo;ll explore the in-place merge sort algorithm and how it works.
"><meta name=keywords content="sort,algorithm"><meta name=robots content="noodp"><link rel=canonical href=https://www.michaelchan.space/posts/in-place-merge-sort-algorithm/><link rel=stylesheet href=https://www.michaelchan.space/styles.css><link rel="shortcut icon" href=https://www.michaelchan.space/favicon.png><meta name=twitter:card content="summary"><meta name=twitter:site content="www.michaelchan.space"><meta name=twitter:creator content="konomichael_"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="In-Place Merge Sort Algorithm"><meta property="og:description" content="Merge sort is a popular sorting algorithm that has an average-case time complexity of O(n log n). The algorithm works by dividing the input array into two halves, sorting them recursively, and then merging them back together. However, the standard merge sort algorithm requires extra memory to hold the two sub-arrays during the merge step, which can be a bottleneck for large arrays. In contrast, in-place merge sort is a variant of the merge sort algorithm that sorts the array in place, using no extra memory.
In this blog post, we&amp;rsquo;ll explore the in-place merge sort algorithm and how it works.
"><meta property="og:url" content="https://www.michaelchan.space/posts/in-place-merge-sort-algorithm/"><meta property="og:site_name" content="Michael's space"><meta property="og:image" content="https://www.michaelchan.space"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2020-04-24 23:22:15 +0800 +0800"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>michael@dev</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://www.michaelchan.space/posts/in-place-merge-sort-algorithm/>In-Place Merge Sort Algorithm</a></h1><div class=post-meta><time class=post-date>2020-04-24 ::</time>
<span class=post-author>Michael Chan</span>
<span class=post-reading-time>:: 7 min read (1302 words)</span></div><span class=post-tags>#<a href=https://www.michaelchan.space/tags/sort/>sort</a>&nbsp;
#<a href=https://www.michaelchan.space/tags/algorithm/>algorithm</a>&nbsp;</span><div class=post-content><div><p>Merge sort is a popular sorting algorithm that has an average-case time complexity of O(n log n). The algorithm works by dividing the input array into two halves, sorting them recursively, and then merging them back together. However, the standard merge sort algorithm requires extra memory to hold the two sub-arrays during the merge step, which can be a bottleneck for large arrays. In contrast, in-place merge sort is a variant of the merge sort algorithm that sorts the array in place, using no extra memory.</p><p>In this blog post, we&rsquo;ll explore the in-place merge sort algorithm and how it works.</p><h2 id=overview-of-merge-sort>Overview of Merge Sort<a href=#overview-of-merge-sort class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Before diving into in-place merge sort, let&rsquo;s briefly review the standard merge sort algorithm. The basic idea of merge sort is to divide the input array into two halves, sort them recursively, and then merge them back together. Here&rsquo;s the Golang code for merge sort:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mergeSort</span>(<span style=color:#a6e22e>arr</span> []<span style=color:#66d9ef>int</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>arr</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>arr</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[:<span style=color:#a6e22e>mid</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>mid</span>:]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span> = <span style=color:#a6e22e>mergeSort</span>(<span style=color:#a6e22e>left</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>right</span> = <span style=color:#a6e22e>mergeSort</span>(<span style=color:#a6e22e>right</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>merge</span>(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>merge</span>(<span style=color:#a6e22e>left</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>right</span> []<span style=color:#66d9ef>int</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>merged</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>left</span>)<span style=color:#f92672>+</span>len(<span style=color:#a6e22e>right</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>left</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>j</span> &lt; len(<span style=color:#a6e22e>right</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span>[<span style=color:#a6e22e>i</span>] &lt; <span style=color:#a6e22e>right</span>[<span style=color:#a6e22e>j</span>] {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>merged</span>[<span style=color:#a6e22e>k</span>] = <span style=color:#a6e22e>left</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>merged</span>[<span style=color:#a6e22e>k</span>] = <span style=color:#a6e22e>right</span>[<span style=color:#a6e22e>j</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>k</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>left</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>merged</span>[<span style=color:#a6e22e>k</span>] = <span style=color:#a6e22e>left</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>k</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> &lt; len(<span style=color:#a6e22e>right</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>merged</span>[<span style=color:#a6e22e>k</span>] = <span style=color:#a6e22e>right</span>[<span style=color:#a6e22e>j</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>k</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>merged</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the above code, the <code>mergeSort()</code> function takes an array <code>arr</code> and sorts it in ascending order using the merge sort algorithm. The base case is when the length of <code>arr</code> is 1 or less, which is already sorted. Otherwise, the function divides <code>arr</code> into two halves, <code>left</code> and <code>right</code>, and sorts each half recursively using <code>mergeSort()</code>. Once the two halves are sorted, the function merges them back together into a single sorted array using the <code>merge()</code> function. The <code>merge()</code> function takes two arrays, <code>left</code> and <code>right</code>, and returns a merged array containing all <code>left</code> and <code>right</code> elements, sorted in ascending order.</p><h2 id=in-place-merge-sort>In-Place Merge Sort<a href=#in-place-merge-sort class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In-place merge sort is a variant of the merge sort algorithm that sorts the array in place, without using any extra memory. The key idea is to merge the two halves of the array by swapping elements in the original array, rather than creating a new array to hold the merged result. This is accomplished by using a divide-and-conquer approach, similar to the standard merge sort algorithm.</p><p>Here&rsquo;s the pseudocode for in-place merge sort:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Sortable</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MergeSort</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Sortable</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mergeSort</span>(<span style=color:#a6e22e>s</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Len</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// merge_sort sort s[start, end) in ascending order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mergeSort</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Sortable</span>, <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>end</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>end</span><span style=color:#f92672>-</span><span style=color:#a6e22e>start</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>end</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>start</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>start</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mergeSort</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>mid</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mergeSort</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>mid</span>, <span style=color:#a6e22e>end</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>merge</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>mid</span>, <span style=color:#a6e22e>end</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>merge</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Sortable</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>rn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span><span style=color:#f92672>-</span><span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>-</span><span style=color:#a6e22e>m</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>rn</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>rn</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>a</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>m</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>rn</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>q</span> = <span style=color:#a6e22e>m</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>rn</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>m</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// find lowest idx such that s[idx] &gt;= s[q]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// if not found, then idx = m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>j</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>j</span><span style=color:#f92672>-</span><span style=color:#a6e22e>i</span>)<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>mid</span>, <span style=color:#a6e22e>q</span>) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>j</span> = <span style=color:#a6e22e>mid</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>ln</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// find highest idx such that s[idx-1] &lt; s[p]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// if not found. then idx = m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>j</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>j</span><span style=color:#f92672>-</span><span style=color:#a6e22e>i</span>)<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>mid</span>, <span style=color:#a6e22e>p</span>) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>j</span> = <span style=color:#a6e22e>mid</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>q</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// sort s[p, q) by rotatation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// if p == m or q == m then rotate twice, which means nothing change
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>m</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>m</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rotate</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> = <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>m</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>merge</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>m</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>merge</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>q</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rotate</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Sortable</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>q</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>m</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// reverse [a, b)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Sortable</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>a</span> &lt; <span style=color:#a6e22e>b</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>a</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>merge</code> function is the core of the in-place merge sort algorithm. It takes as input the <code>Sortable</code> slice to be sorted, the starting index <code>a</code> of the left subarray, the midpoint index <code>m</code> that divides the left and right subarrays, and the ending index <code>b</code> of the right subarray.</p><p>The function first calculates the sizes of the two subarrays as <code>ln = m - a</code> and <code>rn = b - m</code>. If either subarray has size zero, then there is nothing to do, so the function simply returns.</p><p>If both subarrays have size one, the function compares the elements at the two indices <code>a</code> and <code>m</code>. If the element at <code>m</code> is less than the element at <code>a</code>, the function swaps them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>            a=0                                  m=6                                       b=13
</span></span><span style=display:flex><span>             │                                    │                                         │
</span></span><span style=display:flex><span>             ▼                                    ▼                                         ▼
</span></span><span style=display:flex><span>           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
</span></span><span style=display:flex><span>merge      │ -784│ 38  │ 74  │ 238 │ 959 │ 9845│-5467│ 0   │ 0   │  42 │ 905 │7586 │7586 │
</span></span><span style=display:flex><span>           └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</span></span><span style=display:flex><span>                          ▲                                          ▲
</span></span><span style=display:flex><span>                          │                                          │
</span></span><span style=display:flex><span>initialize q              p=2              m = p+q-m=5             q=(m+b)/2=9
</span></span><span style=display:flex><span>                          │                 │                        │
</span></span><span style=display:flex><span>binary search             ▼                 ▼                        ▼
</span></span><span style=display:flex><span>           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
</span></span><span style=display:flex><span>rotate     │ -784│ 38  │-5467│  0  │  0  │ 74  │ 238 │ 959 │9845 │  42 │ 905 │7586 │7586 │
</span></span><span style=display:flex><span>           └─────┴─────┴──┬──┴─────┴─────┴─────┴─────┴─────┴───┬─┴─────┴─────┴─────┴─────┘
</span></span><span style=display:flex><span>                          │                                    │
</span></span><span style=display:flex><span>                          └────────────akready sorted──────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>           ┌─────┬─────┬─────┬─────┬─────┐
</span></span><span style=display:flex><span>merge      │ -784│ 38  │-5467│  0  │  0  │
</span></span><span style=display:flex><span>           └─────┴─────┴─────┴─────┴─────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
</span></span><span style=display:flex><span>merge      │ 74  │ 238 │ 959 │9845 │  42 │ 905 │7586 │7586 │
</span></span><span style=display:flex><span>           └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</span></span></code></pre></div><p>For subarrays with size greater than one, the function uses a binary search to find the index <code>p</code> that divides the left subarray into two parts such that the maximum element in the left subarray is less than or equal to the minimum element in the right subarray. Similarly, it finds the index <code>q</code> that divides the right subarray into two parts such that the maximum element in the left subarray is less than or equal to the minimum element in the right subarray.</p><p>Once the indices <code>p</code> and <code>q</code> are known, the function rotates the slice so that the elements in the left subarray are in the correct order, followed by the elements in the right subarray. The function then recursively merges the left subarray and the right subarray.</p><p>The <code>rotate</code> function takes as input the <code>Sortable</code> slice to be rotated, and three indices <code>p</code>, <code>m</code>, and <code>q</code>. It first reverses the slice from <code>p</code> to <code>m</code>, then reverses the slice from <code>m</code> to <code>q</code>, and finally reverses the entire slice from <code>p</code> to <code>q-1</code>.</p><p>The <code>reverse</code> function takes as input the <code>Sortable</code> slice to be reversed, and two indices <code>a</code> and <code>b</code>. It iterates over the slice from <code>a</code> to <code>b-1</code>, swapping each element with its corresponding element at the opposite end of the slice, until it reaches the midpoint of the slice.</p><p>In summary, the in-place merge sort algorithm sorts a <code>Sortable</code> slice in O(n log n) time and O(1) space(without taking stack in count), by repeatedly dividing the slice into two subarrays, sorting each subarray recursively, and merging the two sorted subarrays in place. The algorithm uses a binary search to find the index that divides each subarray into two parts, and a rotation operation to ensure that the elements in the left subarray are in the correct order, followed by the elements in the right subarray.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://www.michaelchan.space/posts/quick-sort-elegent-implementation/><span class=button__icon>←</span>
<span class=button__text>Quick Sort Elegant Implementation</span></a></span>
<span class="button next"><a href=https://www.michaelchan.space/posts/understanding-pointers-and-the-unsafe-package-in-go/><span class=button__text>Understanding Pointers and the Unsafe Package in Go</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Copyright © 2023 author Michael Chan</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>