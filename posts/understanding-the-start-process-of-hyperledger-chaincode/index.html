<!doctype html><html lang=en><head><title>Understanding the Start Process of Hyperledger Chaincode :: Michael's space</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The topic at hand is User Chaincode (UCC), an essential component for application developers in the realm of blockchain technology. It provides the logic necessary to process states based on a distributed ledger, enabling developers to create complex applications.
"><meta name=keywords content="hyperledger,chaincode,blockchain"><meta name=robots content="noodp"><link rel=canonical href=https://www.michaelchan.space/posts/understanding-the-start-process-of-hyperledger-chaincode/><link rel=stylesheet href=https://www.michaelchan.space/styles.css><link rel="shortcut icon" href=https://www.michaelchan.space/favicon.png><meta name=twitter:card content="summary"><meta name=twitter:site content="www.michaelchan.space"><meta name=twitter:creator content="@konomichael_"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Understanding the Start Process of Hyperledger Chaincode"><meta property="og:description" content="The topic at hand is User Chaincode (UCC), an essential component for application developers in the realm of blockchain technology. It provides the logic necessary to process states based on a distributed ledger, enabling developers to create complex applications.
"><meta property="og:url" content="https://www.michaelchan.space/posts/understanding-the-start-process-of-hyperledger-chaincode/"><meta property="og:site_name" content="Michael's space"><meta property="og:image" content="https://www.michaelchan.space/favicon.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2022-10-24 22:39:40 +0800 +0800"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>michael@dev</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://www.michaelchan.space/posts/understanding-the-start-process-of-hyperledger-chaincode/>Understanding the Start Process of Hyperledger Chaincode</a></h1><div class=post-meta><time class=post-date>2022-10-24 ::</time>
<span class=post-author>konomichael</span>
<span class=post-reading-time>:: 5 min read (982 words)</span></div><span class=post-tags>#<a href=https://www.michaelchan.space/tags/hyperledger/>hyperledger</a>&nbsp;
#<a href=https://www.michaelchan.space/tags/chaincode/>chaincode</a>&nbsp;
#<a href=https://www.michaelchan.space/tags/blockchain/>blockchain</a>&nbsp;</span><div class=post-content><div><p>The topic at hand is <code>User Chaincode (UCC)</code>, an essential component for application developers in the realm of blockchain technology. It provides the logic necessary to process states based on a distributed ledger, enabling developers to create complex applications.</p><p>In the context of Hyperledger Fabric, Chaincode is typically executed within Docker containers. Peers utilize the Docker API to create and launch Chaincode containers. Once a Chaincode container is up and running, it establishes a bi-directional <code>gRPC</code> connection with the Peer, enabling communication via the exchange of ChaincodeMessages. To initiate requests to the Peer, the Chaincode container utilizes the interface provided by the <code>shim</code> package.</p><h2 id=the-typical-structure-of-chaincode>The typical structure of chaincode<a href=#the-typical-structure-of-chaincode class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The typical structure of the chaincode is presented below. Users only need to focus on the implementation of the <code>Init()</code> and <code>Invoke()</code> functions and use the <code>shim.ChaincodeStubInterface</code> structure in them to implement the interaction logic with the ledger.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyChaincode</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyChaincode</span>) <span style=color:#a6e22e>Init</span>(<span style=color:#a6e22e>stub</span> <span style=color:#a6e22e>shim</span>.<span style=color:#a6e22e>ChaincodeStubInterface</span>) <span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>Response</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>shim</span>.<span style=color:#a6e22e>Success</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyChaincode</span>) <span style=color:#a6e22e>Invoke</span>(<span style=color:#a6e22e>stub</span> <span style=color:#a6e22e>shim</span>.<span style=color:#a6e22e>ChaincodeStubInterface</span>) <span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>Response</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>shim</span>.<span style=color:#a6e22e>Success</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>shim</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>MyChaincode</span>{})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=the-start-process>The start process<a href=#the-start-process class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In the <code>main</code> function we called the <code>shim.Start</code> to start a chaincode:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>cc</span> <span style=color:#a6e22e>Chaincode</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>chaincodename</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#e6db74>&#34;CORE_CHAINCODE_ID_NAME&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>chaincodename</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;&#39;CORE_CHAINCODE_ID_NAME&#39; must be set&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>streamGetter</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>streamGetter</span> = <span style=color:#a6e22e>userChaincodeStreamGetter</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>stream</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>streamGetter</span>(<span style=color:#a6e22e>chaincodename</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>chaincodeAsClientChat</span>(<span style=color:#a6e22e>chaincodename</span>, <span style=color:#a6e22e>stream</span>, <span style=color:#a6e22e>cc</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The function first retrieves the value of the <code>CORE_CHAINCODE_ID_NAME</code> in order to get a <code>stream</code>, the implementation of the interface <code>ClientStream</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ClientStream</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>PeerChaincodeStream</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CloseSend</span>() <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>where <code>PeerChaincodeStream</code> is the common stream interface for peer-chaincode communication(send & receive chaincode message ):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PeerChaincodeStream</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Send</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>ChaincodeMessage</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Recv</span>() (<span style=color:#f92672>*</span><span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>ChaincodeMessage</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The above stream interface is default implemented with <code>gRPC</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>internal</span>.<span style=color:#a6e22e>NewClientConn</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>peerAddress</span>, <span style=color:#a6e22e>conf</span>.<span style=color:#a6e22e>TLS</span>, <span style=color:#a6e22e>conf</span>.<span style=color:#a6e22e>KaOpts</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>internal</span>.<span style=color:#a6e22e>NewRegisterClient</span>(<span style=color:#a6e22e>conn</span>)
</span></span></code></pre></div><p>We first establish a gRPC connection to the peer given the <code>peerAddress</code>, then we create a new stream for the client side:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewChaincodeSupportClient</span>(<span style=color:#a6e22e>cc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>ClientConn</span>) <span style=color:#a6e22e>ChaincodeSupportClient</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>chaincodeSupportClient</span>{<span style=color:#a6e22e>cc</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>chaincodeSupportClient</span>) <span style=color:#a6e22e>Register</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>CallOption</span>) (<span style=color:#a6e22e>ChaincodeSupport_RegisterClient</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>stream</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>NewStream</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_ChaincodeSupport_serviceDesc</span>.<span style=color:#a6e22e>Streams</span>[<span style=color:#ae81ff>0</span>], <span style=color:#e6db74>&#34;/protos.ChaincodeSupport/Register&#34;</span>, <span style=color:#a6e22e>opts</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>chaincodeSupportRegisterClient</span>{<span style=color:#a6e22e>stream</span>}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So here we can say that the stream is actually a streaming rpc.</p><h3 id=the-chaincode-side-handler>The chaincode side handler<a href=#the-chaincode-side-handler class=hanchor arialabel=Anchor>&#8983;</a></h3><p>As what we will do next in web programming, we get conn via dialing to a server or listening to the port, we need a handler to process the data we accept from conn. We wrap the <code>stream</code> and <code>chaincode</code> into the <code>handler</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Handler</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// serialLock is used to prevent concurrent calls to Send on the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// PeerChaincodeStream. This is required by gRPC.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>serialLock</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// chatStream is the client used to access the chaincode support server on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the peer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>chatStream</span> <span style=color:#a6e22e>PeerChaincodeStream</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// cc is the chaincode associated with this handler.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>cc</span> <span style=color:#a6e22e>Chaincode</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// state holds the current state of this handler.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>state</span> <span style=color:#a6e22e>state</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Multiple queries (and one transaction) with different txids can be executing in parallel for this chaincode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// responseChannels is the channel on which responses are communicated by the shim to the chaincodeStub.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// need lock to protect chaincode from attempting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// concurrent requests to the peer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>responseChannelsMutex</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>responseChannels</span>      <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>ChaincodeMessage</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After being initialized, the handler sends the first message to the peer to register the chaincode:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>handler</span>.<span style=color:#a6e22e>serialSend</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>peerpb</span>.<span style=color:#a6e22e>ChaincodeMessage</span>{<span style=color:#a6e22e>Type</span>: <span style=color:#a6e22e>peerpb</span>.<span style=color:#a6e22e>ChaincodeMessage_REGISTER</span>, <span style=color:#a6e22e>Payload</span>: <span style=color:#a6e22e>payload</span>}); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;error sending chaincode REGISTER: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>Upon successful registration, the chaincode starts a message processing loop, waiting to receive messages from the peer and messages about its own state transition.</p><p>The chaincode and the peer use the <code>FSM(Finite State Machine)</code> to complete a series of response operations to messages:</p><ul><li><p>When the peer receives a <code>ChaincodeMessage_REGISTER</code> message from the chaincode container, it registers the message to a local Handler structure and returns a <code>ChaincodeMessage_REGISTERED</code> message to the Chaincode container. The peer then updates its status to <code>established</code> and sends a <code>ChaincodeMessage_READY</code> message to the chaincode side, updating its status to <code>ready</code>.</p></li><li><p>The chaincode side receives the <code>ChaincodeMessage_REGISTERED</code> message and updates its status from <code>created</code> to <code>established</code>. Upon receiving the <code>ChaincodeMessage_READY</code> message, it updates its status to &lsquo;ready&rsquo;.</p></li><li><p>The peer sends a <code>ChaincodeMessage_INIT</code> message to the Chaincode container to trigger chaincode initialization operations.</p></li><li><p>When the chaincode container receives the <code>ChaincodeMessage_INIT</code> message, it initializes the required <code>ChaincodeStub</code> structure and calls the <code>Init()</code> method in the chaincode code. After successful initialization, the chaincode container sends a <code>ChaincodeMessage_COMPLETED</code> message to the peer, indicating that it is ready to be invoked.</p></li><li><p>When the chaincode is invoked, the peer sends a <code>ChaincodeMessage_TRANSACTION</code> message to the Chaincode.</p></li><li><p>Upon receiving this message, the Chaincode calls the <code>Invoke()</code> method and sends messages, and based on the logic implemented by the user in the Invoke method, it can send messages such as</p></li><li><p><code>ChaincodeMessage_GET_HISTORY_FOR_KEY</code>,</p></li><li><p><code>ChaincodeMessage_GET_QUERY_RESULT</code>,</p></li><li><p><code>ChaincodeMessage_GET_STATE</code>,</p></li><li><p><code>ChaincodeMessage_GET_STATE_BY_RANGE</code>,</p></li><li><p><code>ChaincodeMessage_QUERY_STATE_CLOSE</code>,</p></li><li><p><code>ChaincodeMessage_QUERY_STATE_NEXT</code>,</p></li><li><p><code>ChaincodeMessage_INVOKE_CHAINCODE</code></p></li></ul><p>to the peer side. The peer processes these messages and responds with a <code>ChaincodeMessage_RESPONSE</code> message. Finally, the chaincode replies with a <code>ChaincodeMessage_COMPLETE</code> message to the Peer to indicate the completion of the call.</p><ul><li>During this process, the peer and chaincode sides periodically send <code>ChaincodeMessage_KEEPALIVE</code> messages to each other to ensure that they remain connected.</li></ul><p>Overall, this system enables communication between the chaincode and the peer using a set of standardized messages and a well-defined protocol, ensuring efficient and reliable interaction.</p><h2 id=summary>Summary<a href=#summary class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In this post, we explored the starting process of the hyperledger chaincode side container. We learned that this process primarily involves establishing a gRPC connection (though other methods like lib-p2p can also be used) with the peer side, and then starting a message handler to process incoming messages. By understanding the chaincode startup process, we gain a deeper understanding of how hyperledger fabric works, which can help us develop more efficient and effective blockchain applications.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://www.michaelchan.space/posts/understanding-the-start-process-of-hyperledger-peer/><span class=button__icon>←</span>
<span class=button__text>Understanding the Start Process of Hyperledger Peer</span></a></span>
<span class="button next"><a href=https://www.michaelchan.space/posts/quick-sort-elegent-implementation/><span class=button__text>Quick Sort Elegant Implementation</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Copyright © 2023 author Michael Chan</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>