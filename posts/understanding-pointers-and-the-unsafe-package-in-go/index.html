<!doctype html><html lang=en><head><title>Understanding Pointers and the Unsafe Package in Go :: Michael's space</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go is a popular programming language known for its simplicity, concurrency, and fast compile times. It features built-in support for pointers, which are variables that store the memory address of another variable. Pointers can be used to manipulate data more efficiently and can enable more advanced programming techniques, such as passing data by reference.
In addition to its built-in support for pointers, Go also provides an unsafe package that allows developers to bypass some of the safety checks that the language provides. This package can be used to perform low-level memory operations that are not possible using the safe language features.
In this blog post, we&amp;rsquo;ll explore how pointers and the unsafe package work in Go by examining a code snippet that uses both features.
"><meta name=keywords content="golang"><meta name=robots content="noodp"><link rel=canonical href=https://www.michaelchan.space/posts/understanding-pointers-and-the-unsafe-package-in-go/><link rel=stylesheet href=https://www.michaelchan.space/styles.css><link rel="shortcut icon" href=https://www.michaelchan.space/favicon.png><meta name=twitter:card content="summary"><meta name=twitter:site content="www.michaelchan.space"><meta name=twitter:creator content="konomichael_"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Understanding Pointers and the Unsafe Package in Go"><meta property="og:description" content="Go is a popular programming language known for its simplicity, concurrency, and fast compile times. It features built-in support for pointers, which are variables that store the memory address of another variable. Pointers can be used to manipulate data more efficiently and can enable more advanced programming techniques, such as passing data by reference.
In addition to its built-in support for pointers, Go also provides an unsafe package that allows developers to bypass some of the safety checks that the language provides. This package can be used to perform low-level memory operations that are not possible using the safe language features.
In this blog post, we&amp;rsquo;ll explore how pointers and the unsafe package work in Go by examining a code snippet that uses both features.
"><meta property="og:url" content="https://www.michaelchan.space/posts/understanding-pointers-and-the-unsafe-package-in-go/"><meta property="og:site_name" content="Michael's space"><meta property="og:image" content="https://www.michaelchan.space"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2019-02-16 15:17:28 +0800 +0800"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>michael@dev</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://www.michaelchan.space/posts/understanding-pointers-and-the-unsafe-package-in-go/>Understanding Pointers and the Unsafe Package in Go</a></h1><div class=post-meta><time class=post-date>2019-02-16 ::</time>
<span class=post-author>Michael Chan</span>
<span class=post-reading-time>:: 4 min read (724 words)</span></div><span class=post-tags>#<a href=https://www.michaelchan.space/tags/golang/>golang</a>&nbsp;</span><div class=post-content><div><p>Go is a popular programming language known for its simplicity, concurrency, and fast compile times. It features built-in support for pointers, which are variables that store the memory address of another variable. Pointers can be used to manipulate data more efficiently and can enable more advanced programming techniques, such as passing data by reference.</p><p>In addition to its built-in support for pointers, Go also provides an <code>unsafe</code> package that allows developers to bypass some of the safety checks that the language provides. This package can be used to perform low-level memory operations that are not possible using the safe language features.</p><p>In this blog post, we&rsquo;ll explore how pointers and the <code>unsafe</code> package work in Go by examining a code snippet that uses both features.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bs</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;h&#39;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;e&#39;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;l&#39;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;l&#39;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;o&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>bs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>)) <span style=color:#f92672>+</span> <span style=color:#a6e22e>n</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#a6e22e>n</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;the length of slice is %d\n&#34;</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>lp</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;the capacity of slice is %d\n&#34;</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>cp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>firstp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>))))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;the first byte of slice is %c\n&#34;</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>firstp</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s break down what this code does, line by line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>bs</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>This line creates a byte slice with length 0 and capacity 10. The <code>make</code> function is used to allocate memory for the slice, and the slice is assigned to the <code>bs</code> variable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;h&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;e&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;l&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;l&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>bs</span> = append(<span style=color:#a6e22e>bs</span>, <span style=color:#e6db74>&#39;o&#39;</span>)
</span></span></code></pre></div><p>These lines append the bytes &lsquo;h&rsquo;, &rsquo;e&rsquo;, &rsquo;l&rsquo;, &rsquo;l&rsquo;, and &lsquo;o&rsquo; to the <code>bs</code> slice, using the <code>append</code> function. The result is a slice with length 5 and capacity 10.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>bs</span>
</span></span></code></pre></div><p><code>p := &bs</code> creates a pointer <code>p</code> that points to the memory address of the <code>bs</code> slice, then <code>n := uintptr(8)</code> creates a <code>uintptr</code> variable <code>n</code> with a value of 8.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>lp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>)) <span style=color:#f92672>+</span> <span style=color:#a6e22e>n</span>))
</span></span><span style=display:flex><span><span style=color:#a6e22e>cp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#a6e22e>n</span>))
</span></span></code></pre></div><p>These lines create two pointers, <code>lp</code> and <code>cp</code>, that point to the memory addresses of the slice length and capacity values, respectively. This is done using the <code>unsafe.Pointer</code> function to convert the <code>p</code> pointer to a <code>uintptr</code> value, adding an offset to the pointer using the <code>+</code> operator, and then converting the result back to a pointer of type <code>*int</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>           p         p+8       p+16
</span></span><span style=display:flex><span>           ┌─────────┬─────────┬─────────┐
</span></span><span style=display:flex><span>           │(uintptr │  (int)  │  (int)  │
</span></span><span style=display:flex><span>SliceHeader│  Data   │  Len    │  Cap    │
</span></span><span style=display:flex><span>           └─┬───────┴─────────┴─────────┘
</span></span><span style=display:flex><span>             │
</span></span><span style=display:flex><span>             │   ┌───┬───┬───┬───┬───┬───┐
</span></span><span style=display:flex><span>             └───► h │ e │ l │ l │ o │...│
</span></span><span style=display:flex><span>                 └───┴───┴───┴───┴───┴───┘
</span></span></code></pre></div><p>The first <code>unsafe.Pointer</code> call converts the <code>p</code> pointer to a <code>uintptr</code> value, and the second <code>unsafe.Pointer</code> call converts it back to a pointer of type <code>unsafe.Pointer</code>. This is necessary because the <code>uintptr</code> value cannot be directly converted to a pointer of type <code>*int</code>.</p><p>The first pointer, <code>lp</code>, has an offset of 8 from the start of the <code>bs</code> slice, which points to the length value held by <code>sliceHeader</code>. The second pointer, <code>cp</code>, has an offset of 16, which points to the capacity value held by <code>sliceHeader</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;the length of slice is %d\n&#34;</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>lp</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;the capacity of slice is %d\n&#34;</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>cp</span>)
</span></span></code></pre></div><p>These lines print the length and capacity values of the <code>bs</code> slice, which are accessed through the <code>lp</code> and <code>cp</code> pointers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>firstp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>))))
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;the first byte of slice is %c\n&#34;</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>firstp</span>)
</span></span></code></pre></div><p>This line creates a pointer <code>firstp</code> that points to the first byte of the <code>bs</code> slice. This is done by first converting the <code>p</code> pointer to a <code>uintptr</code> value(which is the address of <code>data</code> held by <code>sliceHeader</code>), then dereferencing it to access the address, and finally converting the result to a <code>uintptr</code> value and dereferencing it again to access the first byte of the slice.</p><p>The first byte is printed using the <code>%c</code> format specifier, which formats the value as a character.</p><p>In summary, the code we examined demonstrates how to use pointers and the <code>unsafe</code> package in Go to perform low-level memory operations. While the <code>unsafe</code> package can be useful in certain situations, it should be used with caution, as it bypasses some of the safety checks that Go provides. When working with pointers and the <code>unsafe</code> package, it is important to understand how memory is allocated and managed in Go, and to follow best practices for memory management and data manipulation.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://www.michaelchan.space/posts/in-place-merge-sort-algorithm/><span class=button__icon>←</span>
<span class=button__text>In-Place Merge Sort Algorithm</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Copyright © 2023 author Michael Chan</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>