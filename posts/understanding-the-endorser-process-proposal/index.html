<!doctype html><html lang=en><head><title>Understanding the Endorser process proposal :: Michael's space</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In the previous posts, we learned how the peer and chaincode start and knew there&amp;rsquo;re multiple roles in a hyperledger fabric network. In this post, we will have new insights into the endorser. But before we do that, let&amp;rsquo;s have a global view of how the fabric run.
"><meta name=keywords content="hyperledger,endorser,blockchain"><meta name=robots content="noodp"><link rel=canonical href=https://www.michaelchan.space/posts/understanding-the-endorser-process-proposal/><link rel=stylesheet href=https://www.michaelchan.space/styles.css><link rel="shortcut icon" href=https://www.michaelchan.space/favicon.png><meta name=twitter:card content="summary"><meta name=twitter:site content="www.michaelchan.space"><meta name=twitter:creator content="@konomichael_"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Understanding the Endorser process proposal"><meta property="og:description" content="In the previous posts, we learned how the peer and chaincode start and knew there&amp;rsquo;re multiple roles in a hyperledger fabric network. In this post, we will have new insights into the endorser. But before we do that, let&amp;rsquo;s have a global view of how the fabric run.
"><meta property="og:url" content="https://www.michaelchan.space/posts/understanding-the-endorser-process-proposal/"><meta property="og:site_name" content="Michael's space"><meta property="og:image" content="https://www.michaelchan.space/favicon.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2022-11-25 19:09:20 +0800 +0800"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>michael@dev</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://www.michaelchan.space/posts/understanding-the-endorser-process-proposal/>Understanding the Endorser process proposal</a></h1><div class=post-meta><time class=post-date>2022-11-25 ::</time>
<span class=post-author>konomichael</span>
<span class=post-reading-time>:: 8 min read (1623 words)</span></div><span class=post-tags>#<a href=https://www.michaelchan.space/tags/hyperledger/>hyperledger</a>&nbsp;
#<a href=https://www.michaelchan.space/tags/endorser/>endorser</a>&nbsp;
#<a href=https://www.michaelchan.space/tags/blockchain/>blockchain</a>&nbsp;</span><div class=post-content><div><p>In the previous posts, we learned how the peer and chaincode start and knew there&rsquo;re multiple roles in a hyperledger fabric network. In this post, we will have new insights into the endorser. But before we do that, let&rsquo;s have a global view of how the fabric run.</p><h2 id=the-proposal-the-endorser-and-the-order>The proposal, the endorser, and the order<a href=#the-proposal-the-endorser-and-the-order class=hanchor arialabel=Anchor>&#8983;</a></h2><p>A proposal in Hyperledger Fabric is a transaction request sent to the network for processing. It contains all the necessary information related to the transaction, including the sender&rsquo;s identity, the receiver&rsquo;s identity, the amount of the transaction, and any other relevant data. When a proposal is submitted, it is first verified by the endorsing peers to ensure that it is valid and meets the required criteria. Once the proposal is validated, it is sent to the ordering service for further processing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Proposal</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Header</span>    []<span style=color:#66d9ef>byte</span> <span style=color:#e6db74>`protobuf:&#34;bytes,1,opt,name=header,proto3&#34; json:&#34;header,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Payload</span>   []<span style=color:#66d9ef>byte</span> <span style=color:#e6db74>`protobuf:&#34;bytes,2,opt,name=payload,proto3&#34; json:&#34;payload,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Extension</span> []<span style=color:#66d9ef>byte</span>   <span style=color:#e6db74>`protobuf:&#34;bytes,3,opt,name=extension,proto3&#34; json:&#34;extension,omitempty&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The endorser in Hyperledger Fabric is responsible for endorsing the validity of a transaction proposal. Endorsers are selected by the client based on the network&rsquo;s endorsement policy, which specifies the required number of endorsements required to execute a transaction. Endorsers examine the proposal and determine whether it meets the requirements specified by the endorsement policy. If the proposal meets the endorsement policy criteria, the endorser digitally signs the proposal and sends it back to the client for further processing.</p><p>The order in Hyperledger Fabric is responsible for processing and validating endorsed transactions. The ordering service is a separate component in the network that ensures that all transactions are executed in a consistent and sequential order. The order service takes endorsed transactions from the client and creates a block containing the transactions in the correct order. Once the block is created, it is broadcasted to all the nodes in the network for validation and verification. Once the block is validated, it is added to the blockchain, and the transaction is considered complete.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>       Execution Phase             │   Ordering Phase  │    Validation Phase
</span></span><span style=display:flex><span>                                   │                   │
</span></span><span style=display:flex><span>┌─────────────┐                    │                   │      ┌─────────────┐
</span></span><span style=display:flex><span>│   Peer 1    │     1              │                   │      │   Peer 1    │
</span></span><span style=display:flex><span>│ (Endorser)  ◄────────────┐       │                   │ ┌────► (Endorser)  │
</span></span><span style=display:flex><span>└─┬───────────┘            │       │                   │ │    │   6, 7, 8   │
</span></span><span style=display:flex><span>  │        2           ┌───┴───┐   │   ┌───────────┐   │ │    └─────────────┘
</span></span><span style=display:flex><span>  └────────────────────►       │ 3 │   │  Ordering │ 5 │ │
</span></span><span style=display:flex><span>                       │ client├───┼──►│           ├───┼─┤
</span></span><span style=display:flex><span>  ┌────────────────────►       │   │   │  Service  │   │ │    ┌─────────────┐
</span></span><span style=display:flex><span>  │        2           └───┬───┘   │   └───────────┘   │ │    │   Peer 2    │
</span></span><span style=display:flex><span>┌─┴───────────┐            │       │        4          │ ├────► (Endorser)  │
</span></span><span style=display:flex><span>│   Peer 2    ◄────────────┘       │                   │ │    │   6, 7, 8   │
</span></span><span style=display:flex><span>│ (Endorser)  │     1              │                   │ │    └─────────────┘
</span></span><span style=display:flex><span>└─────────────┘                    │                   │ │
</span></span><span style=display:flex><span>                                   │                   │ │
</span></span><span style=display:flex><span>                                   │                   │ │    ┌─────────────┐
</span></span><span style=display:flex><span>┌─────────────┐                    │                   │ │    │   Peer 3    │
</span></span><span style=display:flex><span>│   Peer 3    │                    │                   │ └────►             │
</span></span><span style=display:flex><span>│ (Endorser)  │                    │                   │      │   6, 7, 8   │
</span></span><span style=display:flex><span>└─────────────┘                    │                   │      └─────────────┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 1: Send transaction for endorsement
</span></span><span style=display:flex><span> 2: Transaction with endorser signature and read/write set
</span></span><span style=display:flex><span> 3: Transaction with endorser response
</span></span><span style=display:flex><span> 4: Transactions packed in blocks
</span></span><span style=display:flex><span> 5: Block of transactions
</span></span><span style=display:flex><span> 6: VSCC &amp; MVCC validation
</span></span><span style=display:flex><span> 7: World state updated
</span></span><span style=display:flex><span> 8: Block appended to ledger
</span></span></code></pre></div><h2 id=the-channel>The Channel<a href=#the-channel class=hanchor arialabel=Anchor>&#8983;</a></h2><p>A Hyperledger Fabric <code>channel</code> is a private “subnet” of communication between two or more specific network members, for the purpose of conducting private and confidential transactions. A channel is defined by members (organizations), anchor peers per member, the shared ledger, chaincode application(s) and the ordering service node(s). Each transaction on the network is executed on a channel, where each party must be authenticated and authorized to transact on that channel. Each peer that joins a channel, has its own identity given by a membership services provider (MSP), which authenticates each peer to its channel peers and services.</p><h2 id=process-the-proposal>Process the proposal<a href=#process-the-proposal class=hanchor arialabel=Anchor>&#8983;</a></h2><p>As the above diagram shows, processing the proposal happens in the 2nd step, which invokes <code>Endorser.ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, error)</code> and do the following jobs:</p><ol><li>Validate the proposal</li><li>Simulate the execution of the proposal</li><li>Sign the proposal and read/write set, then return the response</li></ol><h3 id=unpack-and-validate-the-proposal>Unpack and Validate the Proposal<a href=#unpack-and-validate-the-proposal class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Since the proposal is serialized to bytes and signed, we need first unpack the proposal and verify the certification and signature. The <code>proto.Unmarshal</code> is used to deserialize the message into the <code>UnpackedProposal</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UnpackedProposal</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ChaincodeName</span>   <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ChannelHeader</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>common</span>.<span style=color:#a6e22e>ChannelHeader</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Input</span>           <span style=color:#f92672>*</span><span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>ChaincodeInput</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Proposal</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>Proposal</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SignatureHeader</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>common</span>.<span style=color:#a6e22e>SignatureHeader</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SignedProposal</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>SignedProposal</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ProposalHash</span>    []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s worth mentioning that the <code>proposalHash</code> is calculated with <code>sha256</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>propHash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sha256</span>.<span style=color:#a6e22e>New</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>propHash</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>hdr</span>.<span style=color:#a6e22e>ChannelHeader</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>propHash</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>hdr</span>.<span style=color:#a6e22e>SignatureHeader</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>propHash</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>ppBytes</span>)
</span></span></code></pre></div><p>Since the transaction is preprocessed on the channel, we have to find the channel first：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>channel</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Channel</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>up</span>.<span style=color:#a6e22e>ChannelID</span>() <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>channel</span> = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>ChannelFetcher</span>.<span style=color:#a6e22e>Channel</span>(<span style=color:#a6e22e>up</span>.<span style=color:#a6e22e>ChannelID</span>())
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>channel</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>ProposalResponse</span>{<span style=color:#a6e22e>Response</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>Response</span>{<span style=color:#a6e22e>Status</span>: <span style=color:#ae81ff>500</span>, <span style=color:#a6e22e>Message</span>: <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;channel &#39;%s&#39; not found&#34;</span>, <span style=color:#a6e22e>up</span>.<span style=color:#a6e22e>ChannelHeader</span>.<span style=color:#a6e22e>ChannelId</span>)}}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>channel</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Channel</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IdentityDeserializer</span>: <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>LocalMSP</span>,
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As the code shows, if the <code>channelID</code> is provided in the channel header, then we use it to find the channel, else we use the local membership manager to create a default channel.</p><p>The validation is done in the method <code>Endorser.preProcess(up *UnpackedProposal, channel *Channel) error</code>:</p><ol><li>Validate the channel header&rsquo;s type and epoch</li><li>Validate the signature header&rsquo;s nonce and creator, then compare the <code>TxID</code> with <code>Sha256(nonce+creator)</code></li><li>Find the creator by step 2&rsquo;s creator in the channel then validate it.<ol><li>Validate the creator&rsquo;s certificate chain</li><li>Validate the creator&rsquo;s organization unit</li></ol></li><li>Verify signature with Cryptography algorithms</li><li>Find the local transaction by <code>TxId</code> provided in the channel header to avoid replay attacks.</li><li>Check if the chaincode is a system chaincode(<code>CSCC</code>, <code>LSCC</code>, <code>QSCC</code>), if not, ensure the proposal complies with the channel&rsquo;s writers.</li></ol><h3 id=simulate-the-proposal>Simulate the proposal<a href=#simulate-the-proposal class=hanchor arialabel=Anchor>&#8983;</a></h3><p>As the word <code>simulate</code> implies, this part will not change the ledger. To do the simulation, We first need <code>TxSimulator</code> and <code>HistoryQueryExecutor</code>. (Note that <code>txSim</code> acquires a shared lock(read lock) on the <code>stateDB</code>, which will impact the block commits.) Then we call <code>Endorser.simulateProposal</code> to get the result:</p><ol><li><p>invoke <code>callChaincode</code> to call specified chaincode, which will finally invoke the <code>ChaincodeSupport</code>&rsquo;s method <code>Invoke</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ChaincodeSupport</span>) <span style=color:#a6e22e>Invoke</span>(<span style=color:#a6e22e>txParams</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ccprovider</span>.<span style=color:#a6e22e>TransactionParams</span>, <span style=color:#a6e22e>chaincodeName</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>input</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>ChaincodeInput</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>ChaincodeMessage</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ccid</span>, <span style=color:#a6e22e>cctype</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cs</span>.<span style=color:#a6e22e>CheckInvocation</span>(<span style=color:#a6e22e>txParams</span>, <span style=color:#a6e22e>chaincodeName</span>, <span style=color:#a6e22e>input</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>WithMessage</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;invalid invocation&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cs</span>.<span style=color:#a6e22e>Launch</span>(<span style=color:#a6e22e>ccid</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cs</span>.<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>cctype</span>, <span style=color:#a6e22e>txParams</span>, <span style=color:#a6e22e>chaincodeName</span>, <span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>We will first check the invocation and determines if, how, and to where that invocation should be routed. The function <code>CheckInvocation</code> returns the <code>chancodeID</code>, <code>chaincodeType</code>, and error. If the chaincode requires initialization, the <code>chaincodeType</code> will be <code>ChaincodeMessage_INIT</code>, otherwise <code>ChaincodeMessage_TRANSACTION</code>. Remember that we have talked about the <code>chaincodeType</code> in the <a href=posts/understanding-the-start-process-of-hyperledger-chaincode/>previous post</a>.</li><li>We then call <code>Launch()</code> to create and launch chaincode runtime, and finally call <code>dockerClient.CreateContainer</code> to create a docker container.</li><li>Once the container is created successfully, we call <code>execute</code> to run the chaincode. To do that, we first construct the <code>chaincodeMessage</code> with the <code>chaincodeType</code>, <code>payload</code>(which is the <code>input</code> we unmarshaled from the proposal), <code>txID</code>, <code>channelID</code> and then send it to chaincode via gRPC.</li></ol></li><li><p>For operations deploying or upgrading user chaincode through LSCC, it is necessary to use the <code>Execute()</code> method again to initialize or upgrade the user chaincode instance.</p></li></ol><p>The whole simulation may involve multiple rounds of gRPC communication between the endorser and the chaincode and these communications may want to change the ledger, as we said before, the ledger should not be modified during the simulation. So We put the mediate result to the simulator&rsquo;s <code>rwsetBuilder</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// SetState implements method in interface `ledger.TxSimulator`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>txSimulator</span>) <span style=color:#a6e22e>SetState</span>(<span style=color:#a6e22e>ns</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>value</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>checkWritePrecondition</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>rwsetBuilder</span>.<span style=color:#a6e22e>AddToWriteSet</span>(<span style=color:#a6e22e>ns</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// if this has a key level signature policy, add it to the interest
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>checkStateMetadata</span>(<span style=color:#a6e22e>ns</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>Once the simulation is done, we can get the results via <code>GetTxSimulationResults</code>.</li><li>With the simulation results, we can build the <code>chaincodeInterest</code> that the client can pass to the discovery service to get the correct endorsement policy for the chaincode.</li></ol><h3 id=sign-the-endorsement>Sign the endorsement<a href=#sign-the-endorsement class=hanchor arialabel=Anchor>&#8983;</a></h3><p>We have gotten the simulation result, the chaincode&rsquo;s response, the chaincode event, and chaincodeID, we need to wrap them into an endorsement response and signature. A <code>ProposalResonsePayload</code> is shown below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProposalResponsePayload</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ProposalHash</span> []<span style=color:#66d9ef>byte</span> <span style=color:#e6db74>`protobuf:&#34;bytes,1,opt,name=proposal_hash,json=proposalHash,proto3&#34; json:&#34;proposal_hash,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Extension</span>            []<span style=color:#66d9ef>byte</span>   <span style=color:#e6db74>`protobuf:&#34;bytes,2,opt,name=extension,proto3&#34; json:&#34;extension,omitempty&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The field <code>Extension</code> is where we need to put the things in:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>cAct</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>ChaincodeAction</span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Events</span>: <span style=color:#a6e22e>event</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Results</span>: <span style=color:#a6e22e>result</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Response</span>: <span style=color:#a6e22e>response</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ChaincodeId</span>: <span style=color:#a6e22e>ccid</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>cActBytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>cAct</span>)
</span></span></code></pre></div><p>After that, we use <code>EndorsementPlugin</code> to sign the payload:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DefaultEndorsement</span>) <span style=color:#a6e22e>Endorse</span>(<span style=color:#a6e22e>prpBytes</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>sp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>SignedProposal</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>Endorsement</span>, []<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>signer</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>SigningIdentityForRequest</span>(<span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;failed fetching signing identity&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// serialize the signing identity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>identityBytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>signer</span>.<span style=color:#a6e22e>Serialize</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrapf</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;could not serialize the signing identity&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// sign the concatenation of the proposal response and the serialized endorser identity with this endorser&#39;s key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>signature</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>signer</span>.<span style=color:#a6e22e>Sign</span>(append(<span style=color:#a6e22e>prpBytes</span>, <span style=color:#a6e22e>identityBytes</span><span style=color:#f92672>...</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrapf</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;could not sign the proposal response payload&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>endorsement</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>peer</span>.<span style=color:#a6e22e>Endorsement</span>{<span style=color:#a6e22e>Signature</span>: <span style=color:#a6e22e>signature</span>, <span style=color:#a6e22e>Endorser</span>: <span style=color:#a6e22e>identityBytes</span>}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>endorsement</span>, <span style=color:#a6e22e>prpBytes</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s clear the endorsement is composed of two parts: the signature of <code>ProposalResponsePayload+EndorserIdentity</code> and the <code>EndorserIdentity</code>.</p><h2 id=the-proposalresponse>The ProposalResponse<a href=#the-proposalresponse class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The final <code>ProposalResponse</code> returned to the client is shown below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProposalResponse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Version indicates message protocol version
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Version</span> <span style=color:#66d9ef>int32</span> <span style=color:#e6db74>`protobuf:&#34;varint,1,opt,name=version,proto3&#34; json:&#34;version,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Timestamp is the time that the message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// was created as  defined by the sender
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Timestamp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>timestamppb</span>.<span style=color:#a6e22e>Timestamp</span> <span style=color:#e6db74>`protobuf:&#34;bytes,2,opt,name=timestamp,proto3&#34; json:&#34;timestamp,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// A response message indicating whether the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// endorsement of the action was successful
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Response</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span> <span style=color:#e6db74>`protobuf:&#34;bytes,4,opt,name=response,proto3&#34; json:&#34;response,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The payload of response. It is the bytes of ProposalResponsePayload
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Payload</span> []<span style=color:#66d9ef>byte</span> <span style=color:#e6db74>`protobuf:&#34;bytes,5,opt,name=payload,proto3&#34; json:&#34;payload,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The endorsement of the proposal, basically
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the endorser&#39;s signature over the payload
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Endorsement</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Endorsement</span> <span style=color:#e6db74>`protobuf:&#34;bytes,6,opt,name=endorsement,proto3&#34; json:&#34;endorsement,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The chaincode interest derived from simulating the proposal.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Interest</span>             <span style=color:#f92672>*</span><span style=color:#a6e22e>ChaincodeInterest</span> <span style=color:#e6db74>`protobuf:&#34;bytes,7,opt,name=interest,proto3&#34; json:&#34;interest,omitempty&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://www.michaelchan.space/posts/understanding-the-start-process-of-hyperledger-peer/><span class=button__text>Understanding the Start Process of Hyperledger Peer</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Copyright © 2023 author Michael Chan</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>